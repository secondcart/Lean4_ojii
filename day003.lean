import Mathlib

-- 第三話「tactic」

-- ワシ「今日は, Leanを使ってどう証明するかの説明に入る.」
-- 学「はーい.」
-- ワシ「昨日少し, tacticに触れたが, Leanの証明方法は2つある.」
-- ワシ「1つ目は, 証明項を使う方法, 2つ目は, tacticを使う方法だ.
--      ただ, 1つ目はワシもわからないので, 割愛する.」
-- 学「証明方法が違うだけで, 証明できることには変わりない?」
-- ワシ「もちろん!」

-- MIL
-- 証明項を使う方法
example : ∀ m n : Nat, Even n → Even (m * n) := fun m n ⟨k, (hk : n = k + k)⟩ ↦
  have hmn : m * n = m * k + m * k := by rw [hk, mul_add]
  show ∃ l, m * n = l + l from ⟨_, hmn⟩

-- tacticを使う方法
example : ∀ m n : Nat, Even n → Even (m * n) := by
  -- mとnを自然数とし，n=2*kと仮定．
  rintro m n ⟨k, hk⟩
  -- `m * n`がある自然数の2倍であることを証明する必要がある．そこで`m * k`の2倍であることを示す．
  use m * k
  -- `n`を置換する．
  rw [hk]
  -- 後は明らか．
  ring

-- 学「確かに全然違うけど, `example` の所は同じだから, 同じものを証明しているね.」

-- ワシ「tacticは, 段階的に数学の証明を構築するコマンドで沢山種類がある.」
-- ワシ「昨日の例をもう一度見よう.」

example (a b c : ℝ) : a * b * c = b * (a * c) := by -- `by`: tacticモードに入る
  -- `rw`: 同値変形
  rw [mul_comm a b]
  rw [mul_assoc b a c]

-- 学「これはtacticを使う証明?」
-- ワシ「その通り. `by` は, tacticを使う証明の際に, 使うtactic.」
-- ワシ「`rw` は, rewrite(書き換え)を行うtactic. 等式や同値変形(`↔`)を元に書き換える.」
-- 学「おじいちゃん, 少し話それるけど, `ℝ` はどうやって打つの?」
-- ワシ「さす孫! `\R` で打てる. 今回は, `ℝ` の所に, カーソルを当てると,
--      どう打てばいいか表示される.」
-- 学「`mul_comm`, `mul_assoc` はどういう意味?」
-- ワシ「名前から想像できないか?」
-- 学「mulで, commで, assocだから, わかった!
--     `mul_comm` が `a * b = b * a` で, `mul_assoc` が `(a * b) * c = a * (b * c)`?」
-- ワシ「さす孫! Leanでは, 掛け算は左から計算するから,
--      `(a * b) * c` は掛け算を省略して, `a * b * c` とかく.」
-- 学「意外と, 名前から想像できるね.
--    この `mul_comm` や `mul_assoc` はMathlibから来たの?」
-- ワシ「その通り!」

-- ワシ「`rw` がどう使われているかを見ていく. これは, 昨日のようにカーソルを当てるとわかる.」
-- 学「なるほど, goalが変わっていくね.
--     最初goalの左辺が, `a * b * c` だけど, `rw[mul_comm a b]` で `a * b` が `b * a` に
--     変わって, `b * a * c` になって, `rw[mul_assoc b a c]` で, `b * (a * c)` に
--     なって, 左辺=右辺だから, No goalで証明完了?」
-- ワシ「その通り. ただの計算に感じるかもだけど, 左辺=右辺を示したから, これも立派な証明だ.」
-- 学「これって, 引数いるの? たとえば, `rw[mul_comm]` は?」
-- ワシ「引数は必要ない場合もあるけど, これは必要. `rw` は最初に見つけたパターンに適用させる.
--       今回引数なしだと, `a * b * c` を `c * (a * b)` にしてしまう.」
-- ワシ「ちなみに, `rw[mul_comm a]` とかく場合もある.
--      これは, `a * ?` というパターンすべてに対して, `? * a` と書き換える.」

-- ワシ「次の例をみよう.」

example (a b c d e f : ℝ) (h : a * b = c * d) (h' : e = f) : a * (b * e) = c * (d * f) := by
  rw [h']
  rw [← mul_assoc]
  rw [h]
  rw [mul_assoc]

-- 学「えーと, `a`, `b`, `c`, `d`, `e`, `f` が実数で, `a * b = c * d`, `e = f` のとき,
--     `a * (b * e) = c * (d * f)`?」
-- ワシ「その通り!」
-- 学「`rw` は, Mathlibにある定理以外にも, 仮定(`h`, `h'`)にも使えるんだね.」
-- 学「`rw[← mul_assoc]` の `←` は何?」
-- ワシ「これは, 逆方向を意味する. `rw[*]` は左辺を右辺にするもので,
--      右辺を左辺にしたいときは, `rw[← *]` とかく. ちなみに, `←` は `\l` で打てる.」

-- ワシ「`rw` は他にも注意点があるけど, また徐々に話そう. 今日はここまで!」
