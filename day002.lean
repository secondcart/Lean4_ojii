import Mathlib

-- 第二話「証明の道筋&型理論」

-- ワシ「では, Lean4での証明を見ていこう.」
-- 学「はーい. 最初の `import Mathlib` は, Mathlibというライブラリを使うために必要なの?」
-- ワシ「さす孫. その通り.」
-- 学「(何その略語.)」

-- 略語でいうと, 以後たまに, MILやTPLという文字が出ます.
-- これは参照したサイトを示し, よく出るため略語にしています. 以下を意味します.
-- MIL: Mathematics in Lean
-- https://leanprover-community.github.io/mathematics_in_lean/index.html
-- TPL: Theorem Proving in Lean4
-- https://aconite-ac.github.io/theorem_proving_in_lean4_ja/title_page.html
-- LBE: Lean by Example
-- https://lean-ja.github.io/lean-by-example/index.html
-- どちらもLean4では, 定番のドキュメントです.
-- ただし, MILに沿って行うため, コードはほとんどMILです.
-- なので, コードに関しては, MILの表記は省略します.

-- 実数 `a`, `b`, `c` に対して, `a * b * c = b * (a * c)`.
example (a b c : ℝ) : a * b * c = b * (a * c) := by
  rw [mul_comm a b]
  rw [mul_assoc b a c]

-- ワシ「まず, `--` に関しては, コメントとなる. Leanでは, ファイルにコードを書いて
--      処理を行うが, コメントはすべて無視される. コメントは, 説明するときに使うとよい.」
-- 学「確かにコメントで何を証明しているかわかった.
--    普段ノートに書いて友達に説明するのとは違うね.」
-- ワシ「そうだな. Leanにわかるように工夫して書かないといけない.」
-- 学「大変だな.」
-- ワシ「大変だけど, その代わり正しいことを保証してくれる. それに大変じゃない.」
-- 学「?」
-- ワシ「おじいちゃんが丁寧に説明する.」
-- 学「おじいちゃん!」
-- ワシ「ただ, 丁寧に説明する前に, `rw[mul_comm a b]`の左端にカーソルを当ててごらん.」
-- 学「うん, VS Codeの右画面に何か出たよ.」
-- 1 goal
-- a b c : ℝ
-- ⊢ a * b * c = b * (a * c)
-- ワシ「`⊣` の横に書かれているのが, 証明したい命題で, goalという.
--       `a b c : ℝ` は, 仮定を意味する.」
-- ワシ「次は, 一つ下の `rw [mul_assoc b a c]` の左端にカーソルを当ててごらん.」
-- 1 goal
-- a b c : ℝ
-- ⊢ b * a * c = b * (a * c)
-- 学「さっきと同じ... あれ, goalが変わっている!」
-- ワシ「そう. Leanでは, tacticというものを使って, goalを証明していく.
--       その際に, goalをこうやって変形することがある.
--       このように, 途中の段階でどのように証明されていくかがわかる.」
-- 学「もしかして, これが昨日言っていた
--     ユーザーフレンドリーで, インタラクティブで, リアルタイム?.」
-- ワシ「その通り. `rw [mul_assoc b a c]` の右端にカーソルを当てると, No goalと出る.
--       これはエラーがない, つまり証明が正しいことを保証してくれる.」

-- 学「おじいちゃん, 今更だけど, `a b c : ℝ` は, `a b c ∈ ℝ` ではダメなの?」
-- ワシ「確かに同じ意味だけど, Leanではそう書かない. 昨日言った『依存型理論』の話を少しする.」

-- ワシ「型理論は, 『すべての式あるいは項は, それに関連した型をもつ』という考えだ(TPL).
--       今回は, `a b c` が項で, `R` が型になる.」
-- 学「元が『項』で, 集合を『型』とLeanでは表現するということ?」
-- ワシ「確かにそうだが, 『型』は集合とは限らない. 命題にも使う.」
-- 学「命題って, 真偽がはっきりしている文だよね? 『1+1=2』, 『犬は四本足がある』とか.」
-- ワシ「そう. 命題は, `Prop` という型がある. これは, 命題全体の型をさす.
--      たとえば, `P : Prop` は, 項 `P` が型 `Prop` をもつ, つまり `P` が命題を意味する.
--      また, この `P` が型になることもある.」
-- 学「よくわからないけど, 型は何種類もあるの?」
-- ワシ「項に応じて型を作れる. そのため, 表現の幅が広い.
--      また, 項が型に依存しているといえるため, 依存型理論という. もう少し見よう.」

-- `#check`: 型を調べる.
-- 出力結果は, 右画面に出ますが, コメントとして書く.
#check 1 -- 1 : ℕ

#check 2 + 2 = 4 -- 2 + 2 = 4 : Prop
theorem easy : 2 + 2 = 4 :=
  rfl
  -- `:=` 以降は証明部分ですが, 今は気にしなくてよい.

#check easy -- easy : 2 + 2 = 4
#check Prop -- Prop : Type
#check ℕ -- ℕ : Type
#check Type -- Type : Type 1
#check Type 1 -- Type 1 : Type 2

-- 学「`#check 1`, `#check 2 + 2 = 4` はいいとして,
--    確かに `#check easy` で, `easy` という項が, `2 + 2 = 4` という型をもつになるね.」
-- ワシ「そうだな. ただ, `easy : 2 + 2 = 4` は,
--       実際は, `easy` が `2 + 2 = 4` の証明であると解釈する.」
-- `theorem`: 命題を証明する
-- `example`: 名前を付けずに証明
-- 学「`Prop`, `ℕ` は型が `Type` になっているね.」
-- ワシ「`Type` は, 項が再び型となる型のことをいう(LBE). 型宇宙ともいう.」
-- 学「それなら, `Type` の型も `Type` でいいのに, 何で `Type 1` になるの?」
-- ワシ「その考えは自然だが, これは, `Girardのパラドックス` が関係している.
--       ただ難しい話なので, 割愛する.」
-- 学「なるほど, おじいちゃん, ありがとう! 明日は証明方法聞かせて!」
-- ワシ「もちろん!」
